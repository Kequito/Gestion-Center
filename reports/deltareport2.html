<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="gc-base" content="/Gestion-Center/">
  <title>Delta Report 2 ¬∑ Gesti√≥n Center</title>

  <style>
    td[data-h]{background:linear-gradient(90deg, rgba(56,142,60,.18) var(--h,0%), transparent 0)}
    td.badmap[data-h]{background:linear-gradient(90deg, rgba(183,28,28,.25) var(--h,0%), transparent 0)}
    .muted{color:var(--gray-700)}
    .u-gap{height:10px}
  </style>
</head>
<body>
  <gc-shell>
    <h1 class="page-title">Delta Report 2</h1>

    <div class="gc-panel" style="margin-top:14px;">
      <div class="gc-toolbar">
        <input id="search" class="gc-btn gc-btn--ghost" placeholder="üîé Buscar pa√≠s o cola‚Ä¶" style="width:280px; text-align:left;" />
        <button id="btnProcess" class="gc-btn gc-btn--primary">
          <span class="gc-icon">‚öôÔ∏è</span> Procesar texto
        </button>
        <button id="btnClear" class="gc-btn">
          <span class="gc-icon">üßπ</span> Limpiar
        </button>
        <div class="u-right gc-chipset">
          <span class="gc-chip">Se ignoran PS / Post-sale / PS-Auto</span>
          <span class="gc-chip">Solo 1-1, 2-2, 3-3, 4-4, 5-2, 5-5</span>
        </div>
      </div>
      <div class="u-gap"></div>
      <textarea id="raw" class="gc-panel" placeholder="Pega aqu√≠ el texto con encabezados (#, Country, Name, ‚Ä¶). Acepta TABs o espacios; usa '‚ò∞' como separador de filas."
                style="width:100%; min-height:220px; white-space:pre; border:1px solid var(--gray-300);"></textarea>
    </div>

    <div id="out" class="gc-panel" style="margin-top:14px; display:none;">
      <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; margin-bottom:8px;">
        <h3 style="margin:0;">Resultados <span id="resume" class="muted"></span></h3>
        <div class="gc-chipset">
          <span class="gc-chip gc-chip--dark">verde = mayor</span>
          <span class="gc-chip">rojo = menor</span>
          <span class="gc-chip">click en cabeceras para ordenar</span>
        </div>
      </div>

      <div class="gc-panel" style="padding:0;">
        <table id="tbl" class="gc-table gc-table--sticky">
          <thead>
            <tr>
              <th class="sort" data-sort="country">Country</th>
              <th class="sort" data-sort="queue">Queues</th>
              <th class="sort" data-sort="ops"   style="text-align:center;">Number of operators</th>
              <th class="sort" data-sort="avail" style="text-align:center;">Orders available</th>
              <th class="sort" data-sort="total" style="text-align:center;">Total orders</th>
              <th class="sort" data-sort="fullAvail"  style="text-align:center;">Full Total (Avail)</th>
              <th class="sort" data-sort="fullOrders" style="text-align:center;">Full Total (Orders)</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </gc-shell>

  <script type="module" src="../assets/bw/shell.js"></script>

  <script>
    const $  = (s,p=document)=>p.querySelector(s);
    const $$ = (s,p=document)=>Array.from(p.querySelectorAll(s));

    const queueAllow = /(?:^|\s)(?:1-1|2-2|3-3|4-4|5-2|5-5)(?:\s|$)/;
    const isPS       = /(\bPS\b|Post-sale|Post-sale_Auto|-PS\b)/i;

    const fmt = n => Number(n||0).toLocaleString('en-US');
    const cleanCountry = s => String(s||'').replace(/^\d+\.\s*/,'').trim();

    const secondNum = s => { const m = String(s||'').match(/(\d+)\s*\|\s*(\d+)/); return m ? parseInt(m[2],10) : 0; };
    const firstNum  = s => { const m = String(s||'').match(/(\d+)\s*\|\s*(\d+)/); return m ? parseInt(m[1],10) : 0; };
    const firstArrow= s => { const m = String(s||'').match(/(\d+)\s*->\s*\d+/);  return m ? parseInt(m[1],10) : null; };

    // Split robusto por fila: tabs, luego normalizaci√≥n de espacios, luego \s+
    function robustSplit(line, expectedCount){
      let cols = line.split('\t');
      if (cols.length < expectedCount){
        const normalized = line.replace(/\s{2,}/g, '\t'); // grupos de espacios => tab
        cols = normalized.split('\t');
      }
      if (cols.length < expectedCount){
        cols = line.trim().split(/\s+/); // √∫ltimo recurso
      }
      return cols.map(c=>c.trim());
    }

    function findHeaderAndChunks(lines){
      const headIdx = lines.findIndex(l=>{
        const low = l.toLowerCase();
        return low.includes('country') && low.includes('name')
            && low.includes('number of operators') && low.includes('orders');
      });
      if (headIdx === -1) return { headers:[], chunks:[] };

      // Headers con robustSplit tambi√©n
      const tmpCols = lines[headIdx].includes('\t')
        ? lines[headIdx].split('\t').map(c=>c.trim())
        : lines[headIdx].trim().split(/\s{2,}/).map(c=>c.trim());

      const headers = tmpCols;

      const rest = lines.slice(headIdx+1);
      const chunks = [];
      let buf = [];
      for(const ln of rest){
        const t = ln.trim();
        if (t === '‚ò∞'){
          if (buf.length) { chunks.push(buf.join(' ')); buf = []; }
          continue;
        }
        if (t) buf.push(ln);  // mantenemos tabs originales
      }
      if (buf.length) chunks.push(buf.join(' '));

      return { headers, chunks };
    }

    function parseRows(){
      const rawEl = $('#raw');
      const text = (rawEl?.value || '').replace(/\r/g,'').trim();
      if(!text) return [];

      const all   = text.split(/\n/).map(l=>l.replace(/\s+$/,''));
      const lines = all.filter(l=>l.trim() || l.trim()==='‚ò∞');

      const { headers, chunks } = findHeaderAndChunks(lines);
      if (!headers.length || !chunks.length) return [];

      const idx = (name) => headers.findIndex(h => h.toLowerCase() === name.toLowerCase());

      const iCountry = idx('Country');
      const iName    = idx('Name');
      const iOps     = idx('Number of operators');
      const iOrders  = idx('Orders');
      const iCap     = idx('Capacity');
      const iPri     = idx('Priority'); // para fallback de "a -> b"

      if ([iCountry,iName,iOps,iOrders,iCap].some(v => v === -1)) return [];

      const expectedCount = headers.length;
      const rows = [];

      for(const ch of chunks){
        const cols = robustSplit(ch, expectedCount);

        const name = (cols[iName] || '').trim();
        if (!name) continue;
        if (isPS.test(name)) continue;
        if (!queueAllow.test(name)) continue;

        const country = cleanCountry(cols[iCountry] || '');
        const ops     = secondNum(cols[iOps] || '');     // Y de "X | Y"
        // Orders available: 1) Capacity "a -> b"  2) si no existe, Priority "a -> b"
        let avail  = firstArrow(cols[iCap]) ?? firstArrow(cols[iPri]) ?? 0;
        const total = firstNum (cols[iOrders] || '');    // A de "A | B"

        rows.push({ country, queue:name, ops, avail, total });
      }
      return rows;
    }

    function groupByCountry(rows){
      const map = new Map();
      for (const r of rows){
        if (!map.has(r.country)) map.set(r.country, {country:r.country, rows:[], fullAvail:0, fullOrders:0});
        const g = map.get(r.country);
        g.rows.push(r);
        g.fullAvail  += r.avail;
        g.fullOrders += r.total;
      }
      return Array.from(map.values()).sort((a,b)=>b.fullOrders-a.fullOrders);
    }

    function render(rows){
      const tbody  = $('#tbody');
      const resume = $('#resume');
      const out    = $('#out');
      if (!tbody || !resume || !out) return;

      const groups = groupByCountry(rows);
      const allOps  = rows.map(r=>r.ops);
      const allAvail= rows.map(r=>r.avail);
      const allTotal= rows.map(r=>r.total);

      const mm=a=>({min:Math.min(...a,0),max:Math.max(...a,1)});
      const mmOps=mm(allOps), mmAvail=mm(allAvail), mmTotal=mm(allTotal);
      const scale=(v,{min,max})=> max===min?0:Math.round(((v-min)/(max-min))*100);

      tbody.innerHTML='';
      for (const g of groups){
        for(const r of g.rows){
          const tr=document.createElement('tr');
          tr.innerHTML = `
            <td>${g.country}</td>
            <td>${r.queue}</td>
            <td data-h style="text-align:center; --h:${scale(r.ops,mmOps)}%">${fmt(r.ops)}</td>
            <td class="badmap" data-h style="text-align:center; --h:${scale(r.avail,mmAvail)}%">${fmt(r.avail)}</td>
            <td data-h style="text-align:center; --h:${scale(r.total,mmTotal)}%">${fmt(r.total)}</td>
            <td style="text-align:center" class="muted">${fmt(g.fullAvail)}</td>
            <td style="text-align:center" class="muted">${fmt(g.fullOrders)}</td>`;
          tbody.appendChild(tr);
        }
      }
      out.style.display='';
      resume.textContent = `‚Äî ${rows.length} filas ¬∑ ${new Set(rows.map(r=>r.country)).size} pa√≠ses`;
    }

    // Delegaci√≥n de eventos
    document.addEventListener('click', (e)=>{
      if (e.target.closest('#btnProcess')) render(parseRows());
      if (e.target.closest('#btnClear')) {
        const raw = $('#raw'); const search = $('#search'); const out = $('#out');
        if (raw) raw.value=''; if (search) search.value=''; if (out) out.style.display='none';
      }
    });

    document.addEventListener('input', (e)=>{
      if (e.target && e.target.id === 'search') {
        const q = e.target.value.toLowerCase().trim();
        const rows = parseRows().filter(r =>
          r.country.toLowerCase().includes(q) || r.queue.toLowerCase().includes(q)
        );
        render(rows);
      }
    });

    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) render(parseRows());
    });
  </script>
</body>
</html>
